<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>space bar / r</title>
<style>
  :root{
    --size: 850px;        /* 도넛 전체 크기(원) */
    --thickness: 30px;    /* 링 두께 */
    --bg: #272727;
    --track: rgba(255,255,255,0.06);
    --accent-start: #00e5ff;
    --accent-end: #8a00ff;
    --font: 'Noto Sans KR', 'Segoe UI', Roboto, sans-serif;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    font-family:var(--font);
    color:#fff;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .container{
    width:var(--size);
    max-width:94vw;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    gap:14px;
    box-sizing:border-box;
    position:relative;
  }

  .svg-wrap{
    width:100%;
    max-width:var(--size);
    aspect-ratio:1/1;
    position:relative;
  }

  svg{ width:100%; height:100%; transform:rotate(-90deg); display:block; }

  /* 중앙 시간 표시 */
  .time-center{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
  }

  /* 편집/표시용 텍스트 블록 */
  .time-display{
    color:#fff;
    font-weight:700;
    font-size: clamp(28px, 9vw, 78px); /최소 크기 / 비율 / 최대
    letter-spacing:0.6px;
    user-select:none;
    display:flex;
    gap:6px;
    align-items:center;
  }

  /* 각 세그먼트(시/분/초) */
  .segment{
    padding:6px 8px;
    border-radius:6px;
    transition:background 120ms, color 120ms;
    cursor:pointer;
  }
  .segment:hover{ background: rgba(255,255,255,0.03); }
  .segment.selected{
    background: linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    box-shadow: 0 0 0 3px rgba(138,0,255,0.12) inset;
  }

  /* 편집 모드의 숨겨진 입력(화면에 보이지 않음) */
  .hidden-input{
    position:absolute;
    width:1px; height:1px; opacity:0; pointer-events:none;
  }

  /* 컨트롤 버튼들 */
  .controls{
    display:flex;
    gap:10px;
  }
  button{
    background:rgba(255,255,255,0.06);
    color:#fff;
    border:1px solid rgba(255,255,255,0.08);
    padding:8px 14px;
    border-radius:8px;
    cursor:pointer;
    font-size:14px;
  }
  button:disabled{ opacity:0.5; cursor:default; }
  button:hover{ background: rgba(255,255,255,0.09); }

  .hint{
    color:rgba(255,255,255,0.45);
    font-size:13px;
    margin-top:6px;
    text-align:center;
  }

  @media (max-width:480px){
    :root{ --size:360px; --thickness:44px; }
    .time-display{ font-size: clamp(18px, 8vw, 36px); }
  }
</style>
</head>
<body>
  <div class="container" id="app">
    <div class="svg-wrap" aria-hidden="false">
      <svg viewBox="0 0 200 200" role="img" aria-label="타이머 링">
        <defs>
          <linearGradient id="g" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="var(--accent-start)"/>
            <stop offset="100%" stop-color="var(--accent-end)"/>
          </linearGradient>
        </defs>

        <!-- 트랙 -->
        <circle cx="100" cy="100" r="calc(80)" fill="none" stroke="var(--track)" stroke-width="calc(var(--thickness))"></circle>

        <!-- 진행 원 -->
        <circle id="progress" cx="100" cy="100" r="80" fill="none" stroke="url(#g)" stroke-width="56"
                stroke-linecap="round" stroke-dasharray="502.6548245743669" stroke-dashoffset="502.6548245743669">
        </circle>

              </svg>

      <div class="time-center" id="timeCenter">
        <!-- 표시용: 클릭하면 편집 모드 진입 -->
        <div class="time-display" id="timeDisplay">
          <span class="segment" data-part="hours" id="segHours">00</span>
          <span>:</span>
          <span class="segment" data-part="minutes" id="segMinutes">00</span>
          <span>:</span>
          <span class="segment" data-part="seconds" id="segSeconds">00</span>
        </div>

        <!-- 화면상 보이지 않는 실제 입력 요소들(키보드 입력을 위해 사용) -->
        <input class="hidden-input" id="inHours" type="number" inputmode="numeric" min="0" max="999" />
        <input class="hidden-input" id="inMinutes" type="number" inputmode="numeric" min="0" max="59" />
        <input class="hidden-input" id="inSeconds" type="number" inputmode="numeric" min="0" max="59" />
      </div>
    </div>

  

<script>
(function(){
  // 요소
  const segH = document.getElementById('segHours');
  const segM = document.getElementById('segMinutes');
  const segS = document.getElementById('segSeconds');
  const inH = document.getElementById('inHours');
  const inM = document.getElementById('inMinutes');
  const inS = document.getElementById('inSeconds');

  const progress = document.getElementById('progress');
  const timeDisplay = document.getElementById('timeDisplay');
  const timeCenter = document.getElementById('timeCenter');

  // 원 둘레
  const R = 80;
  const C = 2 * Math.PI * R;
  progress.style.strokeDasharray = C;

  // 상태
  let h = 0, m = 1, s = 0; // 사용자가 설정한 값
  let totalSeconds = Math.max(1, h*3600 + m*60 + s);
  let remaining = totalSeconds;
  let running = false;
  let rafId = null;
  let prevTs = null;

  // 현재 선택된 세그먼트 ('hours'|'minutes'|'seconds'|null)
  let selected = null;
  let editing = false;

  // 유틸: 포맷
  function pad(n){ return String(n).padStart(2,'0'); }
  function updateDisplayFromVars(){
    segH.textContent = pad(h);
    segM.textContent = pad(m);
    segS.textContent = pad(s);
  }
  function inputsToTotalSeconds(){
    return Math.max(1, h*3600 + m*60 + s);
  }

  // 남은 시간을 기반으로 진행 표시와 중앙 표시를 업데이트합니다.
  function setProgressByRemaining(){
    // 진행 바 갱신
    const ratio = Math.max(0, Math.min(1, remaining / totalSeconds));
    const offset = C * (1 - ratio);
    progress.style.strokeDashoffset = offset;

    // 편집 중이면 화면 덮어쓰지 않음(원하면 편집 중에도 덮어쓰게 변경 가능)
    if (editing) return;

    // remaining 값을 시/분/초로 변환해서 화면에 표시(실제 내부 h/m/s는 편집 중이지 않으면 동기화)
    const secs = Math.max(0, Math.floor(remaining));
    const hh = Math.floor(secs / 3600);
    const mm = Math.floor((secs % 3600) / 60);
    const ss = secs % 60;

    // 화면 텍스트 갱신
    segH.textContent = String(hh).padStart(2,'0');
    segM.textContent = String(mm).padStart(2,'0');
    segS.textContent = String(ss).padStart(2,'0');
  }

  // 편집 모드 진입/종료
  function enterEditMode(){
    if (editing) return;
    editing = true;
    // 기본 선택은 seconds
    selectSegment('seconds');
    inH.value = h; inM.value = m; inS.value = s;
    setTimeout(()=>document.addEventListener('click', outsideClickListener), 0);
  }

  function exitEditMode(applyChanges=true){
    if (!editing) return;
    editing = false;
    deselectAll();
    document.removeEventListener('click', outsideClickListener);
    if (applyChanges){
      m = clamp(parseInt(inM.value) || 0, 0, 59);
      s = clamp(parseInt(inS.value) || 0, 0, 59);
      h = Math.max(0, parseInt(inH.value) || 0);
      updateDisplayFromVars();
      totalSeconds = inputsToTotalSeconds();
      remaining = totalSeconds; // 편집 후 동기화
      setProgressByRemaining();
    } else {
      inH.value = h; inM.value = m; inS.value = s;
      updateDisplayFromVars();
      totalSeconds = inputsToTotalSeconds();
      remaining = totalSeconds;
      setProgressByRemaining();
    }
  }

  function outsideClickListener(e){
    if (timeCenter.contains(e.target)) return;
    exitEditMode(true);
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  // 선택/해제
  function selectSegment(part){
    deselectAll();
    selected = part;
    const el = part === 'hours' ? segH : part === 'minutes' ? segM : segS;
    el.classList.add('selected');
    const inputEl = part === 'hours' ? inH : part === 'minutes' ? inM : inS;
    inputEl.focus();
    setTimeout(()=> {
      try { inputEl.setSelectionRange(0, inputEl.value.length); } catch(e) {}
    }, 0);
  }

  function deselectAll(){
    selected = null;
    segH.classList.remove('selected');
    segM.classList.remove('selected');
    segS.classList.remove('selected');
  }

  // 휠로 값 조절
  function wheelAdjust(e, part){
    e.preventDefault();
    const delta = Math.sign(e.deltaY) * -1;
    const mult = e.shiftKey ? 10 : 1;
    if (part === 'hours'){
      h = clamp(h + delta * mult, 0, 999);
      inH.value = h;
    } else if (part === 'minutes'){
      m = clamp(m + delta * mult, 0, 59);
      inM.value = m;
    } else if (part === 'seconds'){
      s = clamp(s + delta * mult, 0, 59);
      inS.value = s;
    }
    updateDisplayFromVars();
  }

  // 키 입력
function keyInputHandler(e, part){
  // 타이머 실행 중이면 키보드로 변경 불가
  if (running) {
    // 편집 모드라면 취소하고 포커스 해제
    if (editing) {
      exitEditMode(false);
    }
    // 입력 무시
    e.preventDefault();
    return;
  }

  const inputEl = part === 'hours' ? inH : part === 'minutes' ? inM : inS;
    if (e.key === 'Enter'){
      if (part === 'hours') selectSegment('minutes');
      else if (part === 'minutes') selectSegment('seconds');
      else exitEditMode(true);
      e.preventDefault();
      return;
    }
    if (e.key === 'ArrowUp' || e.key === 'ArrowDown'){
      const delta = e.key === 'ArrowUp' ? 1 : -1;
      const mult = e.shiftKey ? 10 : 1;
      if (part === 'hours') h = clamp(h + delta * mult, 0, 999);
      if (part === 'minutes') m = clamp(m + delta * mult, 0, 59);
      if (part === 'seconds') s = clamp(s + delta * mult, 0, 59);
      inputEl.value = part === 'hours' ? h : part === 'minutes' ? m : s;
      updateDisplayFromVars();
      e.preventDefault();
      return;
    }
    setTimeout(()=> {
      let val = parseInt(inputEl.value,10);
      if (isNaN(val)) val = 0;
      if (part === 'hours'){ h = clamp(val,0,999); inH.value = h; }
      if (part === 'minutes'){ m = clamp(val,0,59); inM.value = m; }
      if (part === 'seconds'){ s = clamp(val,0,59); inS.value = s; }
      updateDisplayFromVars();
    }, 0);
  }

  // 이벤트 바인딩
 timeDisplay.addEventListener('click', (e) => {
  // 타이머 실행 중이면 편집 불가
  if (running) return;

  if (!editing) enterEditMode();
  const seg = e.target.closest('.segment');
  if (seg){
    const part = seg.dataset.part;
    selectSegment(part);
  } else {
    selectSegment('seconds');
  }
});

 [segH, segM, segS].forEach(el => {
  el.addEventListener('wheel', (e) => {
    // 타이머 실행 중이면 휠로 변경 불가
    if (running) { e.preventDefault(); return; }

    if (!editing) enterEditMode();
    const part = el.dataset.part;
    wheelAdjust(e, part);
    selectSegment(part);
  }, { passive:false });
});

  inH.addEventListener('keydown', (e)=> keyInputHandler(e, 'hours'));
  inM.addEventListener('keydown', (e)=> keyInputHandler(e, 'minutes'));
  inS.addEventListener('keydown', (e)=> keyInputHandler(e, 'seconds'));

inH.addEventListener('wheel', (e)=> {
  e.preventDefault();
  if (running) return;
  wheelAdjust(e,'hours');
}, { passive:false });

inM.addEventListener('wheel', (e)=> {
  e.preventDefault();
  if (running) return;
  wheelAdjust(e,'minutes');
}, { passive:false });

inS.addEventListener('wheel', (e)=> {
  e.preventDefault();
  if (running) return;
  wheelAdjust(e,'seconds');
}, { passive:false });

 segH.addEventListener('click', (e)=>{
  e.stopPropagation();
  if (running) return;
  if(!editing) enterEditMode();
  selectSegment('hours');
});
segM.addEventListener('click', (e)=>{
  e.stopPropagation();
  if (running) return;
  if(!editing) enterEditMode();
  selectSegment('minutes');
});
segS.addEventListener('click', (e)=>{
  e.stopPropagation();
  if (running) return;
  if(!editing) enterEditMode();
  selectSegment('seconds');
});

  // 타이머 루프 (remaining을 줄이고 화면 동기화)
  function startTimer(){
    if (running) return;
    totalSeconds = inputsToTotalSeconds();
    if (totalSeconds <= 0) return;
    running = true;
  progress.style.stroke = 'url(#g)';
      if (editing) exitEditMode(true);
    prevTs = performance.now();
    // 남은 시간이 이미 세팅되어 있지 않거나 남아있지 않으면 초기화
    if (!remaining || remaining <= 0 || remaining > totalSeconds) remaining = totalSeconds;
    function tick(now){
      if (!running) return;
      const delta = (now - prevTs) / 1000;
      prevTs = now;
      remaining -= delta;
      if (remaining <= 0){
        remaining = 0;
        setProgressByRemaining();
        stopTimer();
        flashComplete();
        return;
      }
      // 남은 시간 기준으로 화면과 진행바 동기화
      setProgressByRemaining();

      rafId = requestAnimationFrame(tick);
    }
    rafId = requestAnimationFrame(tick);
  }

  function stopTimer(){
    running = false;
      if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }
  function pauseTimer(){ stopTimer();
progress.style.stroke = 'rgba(255,255,255,0.12)'; }

  function resetTimer(){
    stopTimer();
    totalSeconds = inputsToTotalSeconds();
    remaining = totalSeconds;
    // 내부 변수와 화면 동기화
    updateDisplayFromVars();
    setProgressByRemaining();
  }

  // 완료 시 깜박임
  function flashComplete(){
    const el = progress;
    let flashCount = 0;
    const maxFlash = 6;
    const origOpacity = el.style.opacity || '1';
    function f(){
      el.style.opacity = (el.style.opacity === '0.35' ? '1' : '0.35');
      flashCount++;
      if (flashCount < maxFlash) setTimeout(f, 200);
      else el.style.opacity = origOpacity;
    }
    f();
  }

  // 버튼 이벤트
 
  // 스페이스/ R 키 단축 및 Escape로 편집 취소
  document.addEventListener('keydown', (e)=>{
    if (e.code === 'Space'){
      e.preventDefault();
      if (running) pauseTimer(); else startTimer();
    } else if (e.key.toLowerCase() === 'r'){
      resetTimer();
    } else if (e.key === 'Escape' && editing){
      exitEditMode(false);
    }
  });

// 마우스 우클릭을 스페이스바와 동일하게 동작하도록 처리
document.addEventListener('contextmenu', function(e) {
  // 우클릭 기본 메뉴 차단
  e.preventDefault();

  // 스페이스바와 동일한 토글 동작: 실행 중이면 일시정지, 아니면 시작
  if (running) pauseTimer();
  else startTimer();
});

  // 초기 세팅
  updateDisplayFromVars();
  totalSeconds = inputsToTotalSeconds();
  remaining = totalSeconds;
  setProgressByRemaining();

  // stroke-width 동기화
  function updateStrokeWidth(){
    const thickness = getComputedStyle(document.documentElement).getPropertyValue('--thickness').trim();
    if (thickness) progress.setAttribute('stroke-width', parseFloat(thickness));
  }
  updateStrokeWidth();
  const ro = new ResizeObserver(updateStrokeWidth);
  ro.observe(document.documentElement);

  window.addEventListener('blur', ()=>{ if (editing) exitEditMode(true); });

})();
</script>
</body>
</html>
